(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{244:function(a,e,n){"use strict";n.r(e);var t=n(0),r=Object(t.a)({},(function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"扩展运算符（-）"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#扩展运算符（-）"}},[a._v("#")]),a._v(" 扩展运算符（...）")]),a._v(" "),n("h3",{attrs:{id:"基本用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[a._v("#")]),a._v(" 基本用法")]),a._v(" "),n("ul",[n("li",[a._v("该运算符作用正好与rest参数作用相反，用于展开数组为参数序列，用逗号分割。")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("console.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function push(array, ...items) {\n  array.push(...items);\n}\n\nfunction add(x, y) {\n  return x + y;\n}\n\nconst numbers = [4, 38];\nadd(...numbers) // 42\n")])])]),n("h3",{attrs:{id:"应用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[a._v("#")]),a._v(" 应用")]),a._v(" "),n("ol",[n("li",[a._v("复制数组，数组作为一个复合型的数据结构，直接复制的话只是复制了指向数组的指针")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//错误\nconst a1 = [1, 2];\nconst a2 = a1;\na2[0] = 2;\na1 // [2, 2]\n\n//正确\nconst a1 = [1, 2];\n// 写法一\nconst a2 = [...a1];\n// 写法二\nconst [...a2] = a1;\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[a._v("合并数组")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n[...arr1, ...arr2, ...arr3]\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[a._v("与解构赋值结合起来，用于生成新数组，只能将扩展运算符放在最后一位")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('const [first, ...rest] = [1, 2, 3, 4, 5];\nfirst // 1\nrest  // [2, 3, 4, 5]\n\nconst [first, ...rest] = [];\nfirst // undefined\nrest  // []\n\nconst [first, ...rest] = ["foo"];\nfirst  // "foo"\nrest   // []\n')])])]),n("ol",{attrs:{start:"4"}},[n("li",[a._v("转变字符串为数组，可以正确识别四个字节的字符串")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let str = 'x\\uD83D\\uDE80y';\n\nstr.split('').reverse().join('')\n// 'y\\uDE80\\uD83Dx'\n\n[...str].reverse().join('')\n// 'y\\uD83D\\uDE80x'\n")])])]),n("ol",{attrs:{start:"5"}},[n("li",[a._v("将实现了 Iterator 接口的对象转化为数组")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let nodeList = document.querySelectorAll('div');\nlet array = [...nodeList];\n")])])]),n("ul",[n("li",[a._v("nodeList是一个类似数组的对象，可以将其转化为真正的数组")]),a._v(" "),n("li",[a._v("对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组,可以使用Array.from")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let arrayLike = {\n  '0': 'a',\n  '1': 'b',\n  '2': 'c',\n  length: 3\n};\n// TypeError: Cannot spread non-iterable object.\nlet arr = [...arrayLike];\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[a._v("Map 和 Set 结构，Generator 函数")])]),a._v(" "),n("ul",[n("li",[a._v("这些结构都可以转化为数组，扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符")])]),a._v(" "),n("h2",{attrs:{id:"array-from"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#array-from"}},[a._v("#")]),a._v(" Array.from()")]),a._v(" "),n("ul",[n("li",[a._v("Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("let arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n")])])]),n("ul",[n("li",[a._v("值得注意的是扩展运算符也可以将其他结构转化为数组，但扩展运算符是调用遍历器接口做到的，而Array.from()是通过一个对象的length属性，换句话说只要一个对象有length属性就可以将他看做类数组对象")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Array.from({ length: 3 });\n// [ undefined, undefined, undefined ]\n")])])]),n("ul",[n("li",[a._v("如果参数是一个数组，则返回原数组。")]),a._v(" "),n("li",[a._v("该方法还可以接受第二个参数，对新数组中的每个元素进行操作，类似map方法")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Array.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n")])])]),n("h2",{attrs:{id:"array-of"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#array-of"}},[a._v("#")]),a._v(" Array.of()")]),a._v(" "),n("ul",[n("li",[a._v("该函数的出现主要是为了弥补Array构造函数的不足，Array的构造函数会因为参数的数量不同而产生一些不一致的问题，如下")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("Array() // []\nArray(3) // [, , ,]\nArray(3, 11, 8) // [3, 11, 8]\n")])])]),n("ul",[n("li",[a._v("当没有参数是，返回一个空数组，当有一个参数时，将该参数作为数组长度，当参数长度大于俩个时，才以这些参数作为元素构成数组。")])]),a._v(" "),n("h2",{attrs:{id:"数组实例的-copywithin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实例的-copywithin"}},[a._v("#")]),a._v(" 数组实例的 copyWithin()")]),a._v(" "),n("ul",[n("li",[a._v("该方法用于改变数组内部的值通过赋值数组内部其他值来覆盖需要改变的值，该方法接受三个参数\n"),n("ul",[n("li",[a._v("target（必需）：从该位置开始替换数据。")]),a._v(" "),n("li",[a._v("start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。")]),a._v(" "),n("li",[a._v("end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。")])])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n\n// 将3号位复制到0号位\n[].copyWithin.call({length: 5, 3: 1}, 0, 3)\n// {0: 1, 3: 1, length: 5}\n\n// 将2号位到数组结束，复制到0号位\nlet i32a = new Int32Array([1, 2, 3, 4, 5]);\ni32a.copyWithin(0, 2);\n// Int32Array [3, 4, 5, 4, 5]\n")])])]),n("h2",{attrs:{id:"数组实例的-find-和-findindex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实例的-find-和-findindex"}},[a._v("#")]),a._v(" 数组实例的 find() 和 findIndex()")]),a._v(" "),n("ul",[n("li",[a._v("find方法用于找出数组内符合某个条件的值，参数为一回调函数，返回true时表示找到，找到返回该值，找不到返回undefined")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("[1, 4, -5, 10].find((n) => n < 0)\n// -5\n")])])]),n("ul",[n("li",[a._v("findindex方法与上类似，不同的是返回下标，若未找到返回-1")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n")])])]),n("h2",{attrs:{id:"数组实例的fill"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实例的fill"}},[a._v("#")]),a._v(" 数组实例的fill()")]),a._v(" "),n("ul",[n("li",[a._v("该方法使用指定值填充数组，可用于数组的初始化")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n")])])]),n("ul",[n("li",[a._v("该方法也可使用第二个和第三个参数，表示填充开始的位置和结束的位置")])]),a._v(" "),n("h2",{attrs:{id:"数组实例的-entries-，keys-和-values"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实例的-entries-，keys-和-values"}},[a._v("#")]),a._v(" 数组实例的 entries()，keys() 和 values()")]),a._v(" "),n("ul",[n("li",[a._v("遍历器方法，分别返回键数组，值数组，键值对数组（这三个方法扔数组里，没一点卵用）")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n")])])]),n("h2",{attrs:{id:"数组实例的-includes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数组实例的-includes"}},[a._v("#")]),a._v(" 数组实例的 includes()")]),a._v(" "),n("ul",[n("li",[a._v("与字符串的includes类似，检查数组内有没有某个值,可添加第二个参数，表示开始位置，超过数组长度返回false，若为负数，表示倒数，此时超过数组长度，表示从0开始")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("[1, 2, 3].includes(3, 3); \n")])])]),n("h2",{attrs:{id:"对于数组空位的处理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对于数组空位的处理"}},[a._v("#")]),a._v(" 对于数组空位的处理")]),a._v(" "),n("ul",[n("li",[a._v("在ES5中对数组空位的处理是比较不一致的，规则如下\n"),n("ul",[n("li",[a._v("forEach(), filter(), every() 和some()都会跳过空位。")]),a._v(" "),n("li",[a._v("map()会跳过空位，但会保留这个值")]),a._v(" "),n("li",[a._v("join()和toString()会将空位视为undefined，而undefined和null会被处*\n理成空字符串。")])])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// forEach方法\n[,'a'].forEach((x,i) => console.log(i)); // 1\n\n// filter方法\n['a',,'b'].filter(x => true) // ['a','b']\n\n// every方法\n[,'a'].every(x => x==='a') // true\n\n// some方法\n[,'a'].some(x => x !== 'a') // false\n\n// map方法\n[,'a'].map(x => 1) // [,1]\n\n// join方法\n[,'a',undefined,null].join('#') // \"#a##\"\n\n// toString方法\n[,'a',undefined,null].toString() // \",a,,\"\n")])])]),n("ul",[n("li",[a._v("但是在ES6中对此类现象做出了改变，ES6中凡是新增的方法及扩展运算符都将数组空位视为undefined，for...of也不会跳过空位")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// entries()\n[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]\n\n// keys()\n[...[,'a'].keys()] // [0,1]\n\n// values()\n[...[,'a'].values()] // [undefined,\"a\"]\n\n// find()\n[,'a'].find(x => true) // undefined\n\n// findIndex()\n[,'a'].findIndex(x => true) // 0\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);