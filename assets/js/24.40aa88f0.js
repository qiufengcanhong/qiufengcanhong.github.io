(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{246:function(n,t,a){"use strict";a.r(t);var e=a(0),s=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"函数参数的默认值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数参数的默认值"}},[n._v("#")]),n._v(" 函数参数的默认值")]),n._v(" "),a("ul",[a("li",[n._v("ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n")])])]),a("ul",[a("li",[n._v("参数变量是默认声明的，所以不能用let或const再次声明。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo(x = 5) {\n  let x = 1; // error\n  const x = 2; // error\n}\n")])])]),a("ul",[a("li",[n._v("使用参数默认值时，函数不能有同名参数。\n// 不报错")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo(x, x, y) {\n  // ...\n}\n\n// 报错\nfunction foo(x, x, y = 1) {\n  // ...\n}\n")])])]),a("ul",[a("li",[n._v("另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let x = 99;\nfunction foo(p = x + 1) {\n  console.log(p);\n}\nfoo() // 100\nx = 100;\nfoo() // 101\n")])])]),a("ul",[a("li",[n._v("与结构赋值默认值结合使用")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo({x, y = 5}) {\n  console.log(x, y);\n}\nfoo({}) // undefined 5\nfoo({x: 1}) // 1 5\nfoo({x: 1, y: 2}) // 1 2\nfoo() // TypeError: Cannot read property 'x' of undefined\n")])])]),a("ul",[a("li",[n._v("以上这种用法在传参时，无法省略参数，不需要传参的情况，也要传一个空对象，可以对起稍作修改")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo({x, y = 5} = {}) {\n  console.log(x, y);\n}\n\nfoo() // undefined 5\n")])])]),a("ul",[a("li",[n._v("通常情况下，我们将需要设置默认值的参数放在参数序列的尾部，因为放在头部将无法省略传参。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function f(x = 1, y) {\n  return [x, y];\n}\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n")])])]),a("ul",[a("li",[n._v("我们知道在JS中函数也是一个对象，且拥有一个属性----Length,用来返回函数参数的个数，但是当设置了参数默认值之后，这个属性将会失真，无法使用。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n")])])]),a("ul",[a("li",[n._v("一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var x = 1;\nfunction f(x, y = x) {\n  console.log(y);\n}\nf(2) // 2\n\nlet x = 1;\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\nf() // 1\n")])])]),a("h2",{attrs:{id:"rest参数（剩余参数）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rest参数（剩余参数）"}},[n._v("#")]),n._v(" rest参数（剩余参数）")]),n._v(" "),a("ul",[a("li",[n._v("在ES6中引入了新参数rest，用法为（...value），它的作用是将剩余参数存入一个数组中")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function add(...values) {\n  let sum = 0;\n  for (var val of values) {\n    sum += val;\n  }\n  return sum;\n}\nadd(2, 5, 3) // 10\n")])])]),a("ul",[a("li",[n._v("需要注意的是该函数只能放在参数序列的最后一位，否则会报错")])]),n._v(" "),a("h2",{attrs:{id:"name属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#name属性"}},[n._v("#")]),n._v(" name属性")]),n._v(" "),a("ul",[a("li",[n._v("函数的name属性，返回该函数的函数名。")]),n._v(" "),a("li",[n._v("ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('var f = function () {};\n// ES5\nf.name // ""\n// ES6\nf.name // "f"\n')])])]),a("ul",[a("li",[n._v("若果是具名函数，即使把他赋值给其他变量，也会返回原来的名字。")])]),n._v(" "),a("h2",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),a("ul",[a("li",[n._v("ES6允许使用箭头定义函数")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var f = v => v;\n")])])]),a("p",[n._v("等价于")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var f = function(v) {\n  return v;\n};\n")])])]),a("ul",[a("li",[n._v("如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n")])])]),a("ul",[a("li",[n._v("由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('// 报错\nlet getTempItem = id => { id: id, name: "Temp" };\n\n// 不报错\nlet getTempItem = id => ({ id: id, name: "Temp" });\n')])])]),a("ul",[a("li",[n._v("如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("let fn = () => void doesNotReturn();\n")])])]),a("ul",[a("li",[n._v("箭头函数也可以与结构赋值一起使用")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("const full = ({ first, last }) => first + ' ' + last;\n// 等同于\nfunction full(person) {\n  return person.first + ' ' + person.last;\n}\n")])])]),a("ul",[a("li",[n._v("箭头函数可以是函数变得更加美观，也可以简化回调函数")]),n._v(" "),a("li",[a("strong",[n._v("箭头函数虽然有诸多优点，但在使用时，还需注意以下几点")]),n._v(" "),a("ul",[a("li",[a("strong",[n._v("函数体内的this是函数定义是所在的宿主对象，而不是调用时所在的对象")])]),n._v(" "),a("li",[a("strong",[n._v("不可以作为构造函数")])]),n._v(" "),a("li",[a("strong",[n._v("不可以使用arguments对象，可用rest实现相同功能")])]),n._v(" "),a("li",[a("strong",[n._v("不可以使用yield命令，因此箭头函数不能用作 Generator 函数。")])])])])]),n._v(" "),a("hr"),n._v(" "),a("blockquote",[a("p",[n._v("关于第一点尤其值得注意，我们知道的是在普通函数中它的this指针表示函数调用时，调用函数的那个对象，而在箭头函数中，该指针只与定义这个函数的对象有关，也就是说这个函数从定义完成时开始，他的this就是不可改变的，所以箭头函数也不可以使用apply()与call()方法")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\nvar id = 21;\nfoo.call({ id: 42 });\n//id:42\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function Timer() {\n  this.s1 = 0;\n  this.s2 = 0;\n  // 箭头函数\n  setInterval(() => this.s1++, 1000);\n  // 普通函数\n  setInterval(function () {\n    this.s2++;\n  }, 1000);\n}\nvar timer = new Timer();\nsetTimeout(() => console.log('s1: ', timer.s1), 3100);\nsetTimeout(() => console.log('s2: ', timer.s2), 3100);\n")])])]),a("ul",[a("li",[n._v("箭头函数this的指向固定化并不是因为其内部机制绑定this不可改变，而是因为箭头函数根本没有this，导致内部代码快的this就是外部代码块的this，也正因如此，箭头函数无法作为构造函数\n举个栗子：")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("function foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\nvar f = foo.call({id: 1});\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n")])])]),a("ul",[a("li",[n._v("上述结果也是因为箭头函数没有自己的this，导致call()然并卵，所以都指向最外层函数的this")])]),n._v(" "),a("hr")])}),[],!1,null,null,null);t.default=s.exports}}]);