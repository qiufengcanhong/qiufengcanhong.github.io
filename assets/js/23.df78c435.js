(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{245:function(t,e,a){"use strict";a.r(e);var s=a(0),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"属性的简洁表示法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性的简洁表示法"}},[t._v("#")]),t._v(" 属性的简洁表示法")]),t._v(" "),a("ul",[a("li",[t._v("ES6允许在对象中直接写入函数和变量")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('const foo = \'bar\';\nconst baz = {foo};\nbaz // {foo: "bar"}\n// 等同于\nconst baz = {foo: foo};\nconst o = {\n  method() {\n    return "Hello!";\n  }\n};\n\n// 等同于\n\nconst o = {\n  method: function() {\n    return "Hello!";\n  }\n};\n')])])]),a("h2",{attrs:{id:"属性名表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#属性名表达式"}},[t._v("#")]),t._v(" 属性名表达式")]),t._v(" "),a("ul",[a("li",[t._v("即使用变量作为属性名")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let lastWord = 'last word';\n\nconst a = {\n  'first word': 'hello',\n  [lastWord]: 'world'\n};\n\na['first word'] // \"hello\"\na[lastWord] // \"world\"\na['last word'] // \"world\"\n")])])]),a("ul",[a("li",[t._v("也可以表示函数名")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let obj = {\n  ['h' + 'ello']() {\n    return 'hi';\n  }\n};\n\nobj.hello() // hi\n")])])]),a("ul",[a("li",[t._v("但不可以与简洁表示法同时使用")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 报错\nconst foo = 'bar';\nconst bar = 'abc';\nconst baz = { [foo] };\n\n// 正确\nconst foo = 'bar';\nconst baz = { [foo]: 'abc'};\n")])])]),a("ul",[a("li",[t._v("如果属性名为对象，则自动转化为字符串[object Object]")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const keyA = {a: 1};\nconst keyB = {b: 2};\n\nconst myObject = {\n  [keyA]: 'valueA',\n  [keyB]: 'valueB'\n};\n\nmyObject // Object {[object Object]: \"valueB\"}\n")])])]),a("h2",{attrs:{id:"name属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#name属性"}},[t._v("#")]),t._v(" name属性")]),t._v(" "),a("ul",[a("li",[t._v("用于返回对象名")])]),t._v(" "),a("h2",{attrs:{id:"object-is"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-is"}},[t._v("#")]),t._v(" Object.is()")]),t._v(" "),a("ul",[a("li",[t._v("比较俩值是否相等")]),t._v(" "),a("li",[t._v("不同之处在于该方法认为，NAN等于自身，-0与+0相等")])]),t._v(" "),a("h2",{attrs:{id:"object-assign"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-assign"}},[t._v("#")]),t._v(" Object.assign()")]),t._v(" "),a("ul",[a("li",[t._v("枚举所有源对象，并添加到一个新对象，主要用于合并对象")]),t._v(" "),a("li",[t._v("如果有相同的属性名，后面的值会覆盖前面的")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const target = { a: 1, b: 1 };\n\nconst source1 = { b: 2, c: 2 };\nconst source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n")])])]),a("ul",[a("li",[t._v("null与undefined放在第一个位置报错")]),t._v(" "),a("li",[t._v("字符串放在第一个位置会转化为数组对象进行拷贝，其他无效")]),t._v(" "),a("li",[t._v("该方法都是浅复制，只复制本身属性，不复制继承，不复制不可枚举的")]),t._v(" "),a("li",[t._v("对于取值函数会直接取到该值，函数名作为键进行复制")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const source = {\n  get foo() { return 1 }\n};\nconst target = {};\n\nObject.assign(target, source)\n// { foo: 1 }\n")])])]),a("ul",[a("li",[t._v("可用于克隆对象，对对象的初始化，为对象添加属性、方法，合并多个对象")])]),t._v(" "),a("h2",{attrs:{id:"object-getownpropertydescriptors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-getownpropertydescriptors"}},[t._v("#")]),t._v(" Object.getOwnPropertyDescriptors()")]),t._v(" "),a("ul",[a("li",[t._v("返回对象属性的描述对象")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const obj = {\n  foo: 123,\n  get bar() { return 'abc' }\n};\n\n###Object.getOwnPropertyDescriptors(obj)\n// { foo:\n//    { value: 123,\n//      writable: true,\n//      enumerable: true,\n//      configurable: true },\n//   bar:\n//    { get: [Function: bar],\n//      set: undefined,\n//      enumerable: true,\n//      configurable: true } }\n")])])]),a("ul",[a("li",[t._v("该方法用于解决Object.assign无法识别默认操作属性setter和getter")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const source = {\n  set foo(value) {\n    console.log(value);\n  }\n};\n\nconst target2 = {};\nObject.defineProperties(target2, Object.getOwnPropertyDescriptors(source));\nObject.getOwnPropertyDescriptor(target2, 'foo')\n// { get: undefined,\n//   set: [Function: foo],\n//   enumerable: true,\n//   configurable: true }\n")])])]),a("h2",{attrs:{id:"proto-属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proto-属性"}},[t._v("#")]),t._v(" __proto__属性")]),t._v(" "),a("ul",[a("li",[t._v("作为指针，指向该对象的原型对象")])]),t._v(" "),a("h2",{attrs:{id:"object-setprototypeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-setprototypeof"}},[t._v("#")]),t._v(" Object.setPrototypeOf()")]),t._v(" "),a("ul",[a("li",[t._v("设置一个对象的原型对象，返回值为参数本身")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let proto = {};\nlet obj = { x: 10 };\nObject.setPrototypeOf(obj, proto);\n\nproto.y = 20;\nproto.z = 40;\n\nobj.x // 10\nobj.y // 20\nobj.z // 40\n")])])]),a("p",[t._v("##Object.getPrototypeOf()")]),t._v(" "),a("ul",[a("li",[t._v("读取一个对象的原型对象\n"),a("code",[t._v("Object.getPrototypeOf(obj);")])])]),t._v(" "),a("h2",{attrs:{id:"super关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#super关键字"}},[t._v("#")]),t._v(" super关键字")]),t._v(" "),a("ul",[a("li",[t._v("我们都知道this对象指向当前对象本身，ES6又新增了一个参数super，用于指向当前对象的原型对象，该属性只可以用在对象的方法里，目前只有对象方法的简写法可以被识别为对象的方法，即")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 报错\nconst obj = {\n  foo: super.foo\n}\n\n// 报错\nconst obj = {\n  foo: () => super.foo\n}\n\n// 报错\nconst obj = {\n  foo: function () {\n    return super.foo\n  }\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const proto = {\n  x: 'hello',\n  foo() {\n    console.log(this.x);\n  },\n};\n\nconst obj = {\n  x: 'world',\n  foo() {\n    super.foo();\n  }\n}\n\nObject.setPrototypeOf(obj, proto);\n\nobj.foo() // \"world\"\n")])])]),a("h3",{attrs:{id:"object-keys"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-keys"}},[t._v("#")]),t._v(" Object.keys()")]),t._v(" "),a("ul",[a("li",[t._v("遍历键（非继承，可遍历）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let {keys, values, entries} = Object;\nlet obj = { a: 1, b: 2, c: 3 };\n\nfor (let key of keys(obj)) {\n  console.log(key); // 'a', 'b', 'c'\n}\n\nfor (let value of values(obj)) {\n  console.log(value); // 1, 2, 3\n}\n\nfor (let [key, value] of entries(obj)) {\n  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]\n}\n")])])]),a("h3",{attrs:{id:"object-values"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-values"}},[t._v("#")]),t._v(" Object.values()")]),t._v(" "),a("ul",[a("li",[t._v("遍历值（ ，）")]),t._v(" "),a("li",[t._v("不遍历Symbol")])]),t._v(" "),a("h3",{attrs:{id:"object-entries（）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-entries（）"}},[t._v("#")]),t._v(" Object.entries（）")]),t._v(" "),a("ul",[a("li",[t._v("遍历键值对（ ，）")]),t._v(" "),a("li",[t._v("不遍历Symbol")]),t._v(" "),a("li",[t._v("除遍历对象外，还可以配合转化为Map结构")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const obj = { foo: 'bar', baz: 42 };\nconst map = new Map(Object.entries(obj));\nmap // Map { foo: \"bar\", baz: 42 }\n")])])]),a("h2",{attrs:{id:"对象的扩展运算符（es2017）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的扩展运算符（es2017）"}},[t._v("#")]),t._v(" 对象的扩展运算符（ES2017）")]),t._v(" "),a("p",[t._v("#####（1）解构赋值")]),t._v(" "),a("ul",[a("li",[t._v("对象的解构赋值是将可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。")]),t._v(" "),a("li",[t._v("由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。")]),t._v(" "),a("li",[t._v("解构赋值必须是最后一个参数")]),t._v(" "),a("li",[t._v("解构赋值是浅复制\n#####（2）扩展运算符")]),t._v(" "),a("li",[t._v("扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let z = { a: 3, b: 4 };\nlet n = { ...z };\nn // { a: 3, b: 4 }\n")])])]),a("ul",[a("li",[t._v("比Object.assign简单，而且也是浅复制")])]),t._v(" "),a("h2",{attrs:{id:"对象的各种遍历"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的各种遍历"}},[t._v("#")]),t._v(" 对象的各种遍历")]),t._v(" "),a("p",[t._v("ES6 一共有5种方法可以遍历对象的属性。")]),t._v(" "),a("p",[t._v("#####（1）for...in")]),t._v(" "),a("ul",[a("li",[t._v("for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。")])]),t._v(" "),a("p",[t._v("#####（2）Object.keys(obj)")]),t._v(" "),a("ul",[a("li",[t._v("Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。")])]),t._v(" "),a("p",[t._v("#####（3）Object.getOwnPropertyNames(obj)")]),t._v(" "),a("ul",[a("li",[t._v("Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。")])]),t._v(" "),a("p",[t._v("#####（4）Object.getOwnPropertySymbols(obj)")]),t._v(" "),a("ul",[a("li",[t._v("Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。")])]),t._v(" "),a("p",[t._v("#####（5）Reflect.ownKeys(obj)")]),t._v(" "),a("ul",[a("li",[t._v("Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。")])]),t._v(" "),a("p",[t._v("######以上的5种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。")]),t._v(" "),a("ul",[a("li",[t._v("首先遍历所有数值键，按照数值升序排列。")]),t._v(" "),a("li",[t._v("其次遍历所有字符串键，按照加入时间升序排列。")]),t._v(" "),a("li",[t._v("最后遍历所有 Symbol 键，按照加入时间升序排列。")])])])}),[],!1,null,null,null);e.default=n.exports}}]);