(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{238:function(a,t,n){"use strict";n.r(t);var e=n(0),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"let用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#let用法"}},[a._v("#")]),a._v(" let用法")]),a._v(" "),n("p",[a._v("ES6新增了let命令，用法与var类似，主要用于声明变量，且逐渐代替var，与var的区别为，其声明的变量只在自己所在的块级作用域内有效。\neg:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 10\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var a = [];\nfor (let i = 0; i < 10; i++) {\n  a[i] = function () {\n    console.log(i);\n  };\n}\na[6](); // 6\n")])])]),n("p",[a._v("由于var不支持块级作用域所以在循环时时声明循环变量，与在循环外部声明并无区别。而let关键字支持块级作用域每次调用函数时都可以在块内找到变量i，并进行输出。\n  值得注意的是一个for循环并不"),n("strong",[a._v("一个")]),a._v("块级作用域，而是俩个，循环体作为子作用域，而循环头部属于父级作用域。\neg:")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("for (let i = 0; i < 3; i++) {\n  let i = 'abc';\n  console.log(i);\n}\n// abc\n// abc\n// abc\n")])])]),n("p",[a._v("补充一点，在ES5中只有全局作用域和函数作用域，除此之外，几乎所有带{}的作用域都可以看做块级作用域")]),a._v(" "),n("h2",{attrs:{id:"变量提升"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[a._v("#")]),a._v(" 变量提升")]),a._v(" "),n("p",[a._v("我们都知道在使用var声明变量时，可以先使用，而后声明，此时程序也不会报错，只是将变量当做undfined使用，这样会给编程带来不可预料的问题，也不是一种良好的编程习惯。在ES6中使用let关键字声明变量，需严格遵守先声明，后使用的原则，否则抛出错误。")]),a._v(" "),n("h2",{attrs:{id:"暂时性死区"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#暂时性死区"}},[a._v("#")]),a._v(" 暂时性死区")]),a._v(" "),n("p",[a._v("由上文我们已经知道，let声明的变量只在自己的块级作用域内起作用，那么若是想使用在外部声明的同名变量，又会怎么样呢？")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("var tmp = 123;\nif (true) {\n  tmp = 'abc'; // ReferenceError\n  let tmp;\n}\n")])])]),n("p",[a._v("上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。\n  ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n  总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”")]),a._v(" "),n("h2",{attrs:{id:"不允许重复声明"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不允许重复声明"}},[a._v("#")]),a._v(" 不允许重复声明")]),a._v(" "),n("p",[a._v("不同于var，let不允许重复申明")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 报错\nfunction () {\n  let a = 10;\n  var a = 1;\n}\n\n// 报错\nfunction () {\n  let a = 10;\n  let a = 1;\n}\n")])])]),n("p",[a._v("因此，不能在函数内部重新声明参数。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("function func(arg) {\n  let arg; // 报错\n}\nfunction func(arg) {\n  {\n    let arg; // 不报错\n  }\n}\n")])])]),n("h2",{attrs:{id:"const用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#const用法"}},[a._v("#")]),a._v(" const用法")]),a._v(" "),n("p",[a._v("const命令用来声明常量，即所声明的值不可改变，改变则抛出错误。")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("const PI = 3.1415;\nPI // 3.1415\n\nPI = 3;\n// TypeError: Assignment to constant variable.\n")])])]),n("p",[a._v("  const命令与let相同的是其也只在它所属的块级作用域内起作用，也存在暂时性死区。\n  然而事无绝对，const所声明的值只是设置其变量所指向的指针不可改变，而指针所指向具体物理地址的值还是可以改变的，也就是说，对于number类型，String类型及Boolean类型不可改变，而对于Object及Array类型不可以改变对象指针或数组指针指向的位置，但其内的元素却是可以改变的。")]),a._v(" "),n("h2",{attrs:{id:"全局变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#全局变量"}},[a._v("#")]),a._v(" 全局变量")]),a._v(" "),n("p",[a._v("  在ES5中，声明的全局变量直接与顶层对象window挂钩，为window对象的属性（在node中为global）,这种做法会为程序带来一些不可预知的错误，因此在ES6中对其作出了优化，但也并未完全摈弃这种做法，只是用var声明的全局变量依然为顶层对象window的属性，而使用const与let所声明的则与window对象没有关系。")])])}),[],!1,null,null,null);t.default=s.exports}}]);