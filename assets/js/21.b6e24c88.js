(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{243:function(a,s,t){"use strict";t.r(s);var e=t(0),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("hr"),a._v(" "),t("h2",{attrs:{id:"构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[a._v("#")]),a._v(" 构造函数")]),a._v(" "),t("ul",[t("li",[a._v("在ES6中可以这样定义正则表答式")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const reg=new RegExp(/asd/gi,'i');\n 第二个模式会覆盖之前原正则表达式中的模式（ES5中不支持这么做）；\n")])])]),t("hr"),a._v(" "),t("h2",{attrs:{id:"字符串方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串方法"}},[a._v("#")]),a._v(" 字符串方法")]),a._v(" "),t("hr"),a._v(" "),t("ul",[t("li",[a._v("字符串中的方法match()、replace()、search()和split()，可能会用到正则表达式，在ES6中这些方法的用法不变，但是内部的调用方式由String的实例对象变成了RegExp的实例对象")])]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"修饰符u"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符u"}},[a._v("#")]),a._v(" 修饰符u")]),a._v(" "),t("hr"),a._v(" "),t("ul",[t("li",[a._v("在ES6中新增了u修饰符，用于匹配unicode16的字符")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n/^\\uD83D/.test('\\uD83D\\uDC2A') // true\n")])])]),t("hr"),a._v(" "),t("ul",[t("li",[a._v("在ES5中.字符用于匹配除换行之外的所有单个字符，但是无法匹配Unicode16的字符，在ES6中可以使用u操作符进行匹配")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var s = '𠮷';\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n")])])]),t("ul",[t("li",[a._v("只有在加了修饰符u之后，所有量词才会按Unicode匹配大于）0xFFFF的字符")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n")])])]),t("ul",[t("li",[a._v("u也会影响到一些预定义模式，如\\S匹配所有不是空格的字符，但无法匹配码点大于）0xFFFF的字符，此时可以加上u修饰符")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n")])])]),t("hr"),a._v(" "),t("h2",{attrs:{id:"修饰符y"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符y"}},[a._v("#")]),a._v(" 修饰符y")]),a._v(" "),t("hr"),a._v(" "),t("p",[a._v("此修饰符与g修饰类似，都是全局修饰符，后一个匹配过程会从前一个配成功的位置下一个开始，但是y修饰符必须以后一个开始的字符作为第一个用于匹配的字符，而g修饰符表示后文中包含即可。\n举个栗子：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('const str=\'asdasd_asdasd\';\nconst reg_y=/asd/y;\nconst reg_g=/asd/g;\nreg_y.exec(str);\n//["asd", index: 0, input: "asdasd_asdasd"]\nreg_y.exec(str);\n//["asd", index: 3, input: "asdasd_asdasd"]\nreg_y.exec(str);\n//null\nreg_g.exec(str)\n//["asd", index: 0, input: "asdasd_asdasd"]\nreg_g.exec(str)\n//["asd", index: 3, input: "asdasd_asdasd"]\nreg_g.exec(str)\n//["asd", index: 7, input: "asdasd_asdasd"]\nreg_g.exec(str)\n//["asd", index: 10, input: "asdasd_asdasd"]\n')])])]),t("ul",[t("li",[a._v("由此，在ES6中正则对象多设置了sticky用以检测是否设置了y修饰符")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("reg_g.sticky\n\\\\false\nreg_y.sticky\n\\\\true\n")])])]),t("ul",[t("li",[a._v("在ES6中在正则对象中也新增了属性flags,该属性用来返回正则对象的修饰符。")])]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"修饰符s-dotall（提案）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符s-dotall（提案）"}},[a._v("#")]),a._v(" 修饰符s:dotAll（提案）")]),a._v(" "),t("hr"),a._v(" "),t("ul",[t("li",[a._v("我们已知预定义模式.可以匹配除行终止符（换行，回车等）外的其他一切字符，但有时我们需要匹配任意字符，这是.就显得有些不堪使用了，于是有提议是添加s修饰符使.可以匹配任意字符， 但目前好像还没有添加使用（2017/10/15）\n"),t("code",[a._v("Google Chrome\t61.0.3163.91 (64-bit) JavaScript\tV8 6.1.534.37")])])]),a._v(" "),t("hr"),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"先行断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#先行断言"}},[a._v("#")]),a._v(" 先行断言")]),a._v(" "),t("ul",[t("li",[a._v("是指x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("/\\d+(?=%)/.exec('100% of US presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')   \n")])])]),t("h2",{attrs:{id:"后行断言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#后行断言"}},[a._v("#")]),a._v(" 后行断言")]),a._v(" "),t("ul",[t("li",[a._v("“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?<=y)x/。比如，只匹配美元符号之后的数字，要写成/(?<=$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?<!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?<!$)\\d+/。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const RE_DOLLAR_PREFIX = /(?<=\\$)foo/g;\n'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');\n// '$bar %foo foo'\n")])])]),t("hr")])}),[],!1,null,null,null);s.default=r.exports}}]);